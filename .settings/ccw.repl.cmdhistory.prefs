cmdhistory=["(println 4)" "(take 3 (repeatedly (rand 10)))" "(take 3 (repeat (rand 10)))" "(take 3 (repeatedly \#(rand 10)))" "(rand)" "(random)" "(rand-float)" "(rand-int)" "(rand-int 10)" "(random 20)" "(quil.core/random 20)" "(pow 2 3)" "(def xy 55)" "xy" "(dbg xy)" "(range 10)" "(into [] (range 10))" "(set [1 2 2 3])" "(set [1 2 3 3])" "(set [1 2 3])" "(set [1 2 3 4 5])" "(combo/permutation-index [\\\\d \\\\a \\\\b \\\\c])" "(clojure.math.combinatorics/permutation-index [\\\\d \\\\a \\\\b \\\\c])" "(range 1 10)" "(for [x (range 1 (inc 5))\\n                      y (range 1 (inc 5))\\n                      \:when (and \\n                         (<\= (+ x y) 5)\\n                         (> 0 (+ x y)))]\\n                  {\:coeff (- (rand-int 20) 10) \\n                     \:x x \\n                     \:y y})" "(for [x (range 5) y (range 5)] {\:x x \:y y})" "(for [x (range 5) y (range 5) \:when (< (+ x y) 5)] {\:x x \:y y})" "(def degree 5)" "(for [x (range 1 (inc degree))\\n                      y (range 1 (inc degree))\\n                      \:when (and \\n                         (<\= (+ x y) degree)\\n                         (> 0 (+ x y)))]\\n                  {\:coeff (- (rand-int 20) 10) \\n                     \:x x \\n                     \:y y})" "(for [x (range (inc degree))\\n                      y (range (inc degree))\\n                      \:when (and \\n                         (<\= (+ x y) degree)\\n                         (> 0 (+ x y)))]\\n                  {\:coeff (- (rand-int 20) 10) \\n                     \:x x \\n                     \:y y})" "(for [x (range (inc degree))\\n                      y (range (inc degree))\\n                      \:when (and \\n                         (<\= (+ x y) degree)\\n                         (> (+ x y) 0))]\\n                  {\:coeff (- (rand-int 20) 10) \\n                     \:x x \\n                     \:y y})" "((fn [x y] (+ x y)) 3 4)" "(type (range 1 10))" "(range -5 5)" "(range -5 5 0.1)" "(random)" "(rand)" "(rand-or-zero -10 10 0.5)" "(conj 2 [1 2 3])" "(conj [1 2 3] 2)" "(constrain 3.0 4 7)" "\:>>" "\:sdfgfdgs" "(some true false true)" "(some [1 0 0 2 3 0])" "(doc some)" "(source some)" "(type (rest [1 2 3]))" "(rest [1 2 3 4])" "(type (rest '(1 2 3)))" "(group-by \#(nth % 2) [[1 2 3] [2 2 4] [2 2 3] [5 4 3] [2 3 1] [5 4 4]])" "(partition-by \#(nth % 2) [[1 2 3] [2 2 4] [2 2 3] [5 4 3] [2 3 1] [5 4 4]])" "(print 55)" "(cemerick.piggieback/cljs-repl (cljs.repl.rhino/repl-env))" "(predicate '(1 2 3))" "(let [num (atom 1)\\n      s1 @num]\\n  (swap\! num inc)\\n  (println \\"State 1\:\\" s1)\\n  (println \\"Current state\:\\" @num))" "(let [num (atom 1)\\n      s1 @num]\\n  (future swap\! num inc)\\n  (println \\"State 1\:\\" s1)\\n  (println \\"Current state\:\\" @num))" "{\:keys [a b c d]}" "{\:keys [\:a \:b \:c \:d]}" "(bean {\:keys [\:a \:b \:c \:d]})" "(hash-unordered-coll {\:keys [\:a \:b \:c \:d]})" "(into [] {\:keys [\:a \:b \:c \:d]})" "(assoc {\:keys [\:a \:b \:c \:d]} \:e 5)" "(assoc\! {\:keys [\:a \:b \:c \:d]} \:e 5)" "(hash-map {\:keys [\:a \:b \:c \:d]})" "(sorted-map {\:keys [\:a \:b \:c \:d]})" "(type {})" "(into clojure.lang.PersistentArrayMap {\:keys [\:a \:b \:c \:d]})" "(into clojure.lang.PersistentArrayMap. {\:keys [\:a \:b \:c \:d]})" "(into (clojure.lang.PersistentArrayMap.) {\:keys [\:a \:b \:c \:d]})" "(state-atom)" "(count [1])" "(clojure.string/split \\"sdfg\\" \\"\\")" "(into [] \\"sdfgsdfg\\")" "(5 in [2 3 5])" "(5 index [2 3 5])" "(index [2 3 5] 5)" "(contains? \\"sdfg-d\\" \\\\-)" "(into [] \\"fg-dfg-\\")" "(contains? [\\\\f \\\\g \\\\- \\\\d \\\\f \\\\g \\\\-] \\\\-)" "(contains? \\\\- [\\\\f \\\\g \\\\- \\\\d \\\\f \\\\g \\\\-])" "(contains? [\\\\f \\\\g \\\\- \\\\d \\\\f \\\\g \\\\-] \\"-\\")" "(into list \\"sdfg-dsfg\\")" "(into '() \\"sdfg-dsfg\\")" "(def x (into '() \\"sdfg-dsfg\\"))" "(contains? x 's')" "(contains? x \\"s\\")" "(contains? x \\\\s)" "(in? [2 3 5] 5)" "(defn in? [col item]\\n  (when-let [col* (seq col)]\\n    (\= item (first col*))\\n    (recur (next col*) item)))" "(in? [2 3 5] 5)" "(member? 5 [2 3 5])" "(defn member?\\n  [item series]\\n  (if (some \#(\= item %) series) true false))" "(member? 5 [2 3 5])" "(member? 7 [2 3 5])" "(<- 5 [2 3 5])" "(member? 7 [2 3 5])" "(member? 5 [2 3 5])" "(filter \#\\"[0-9]*\\" \\"dsfg34536ddfg6\\")" "(filter \#(Character/isDigit %) \\"dsfg34536ddfg6\\")" "(->> \\"sdfg9809sdfgsdgf\\"\\n                      (filter \#(Character/isDigit))\\n                      (map int)\\n                      (sort))" "(->> (into [] \\"sdfg9809sdfgsdgf\\")\\n                      (filter \#(Character/isDigit))\\n                      (map int)\\n                      (sort))" "(->> (into [] \\"sdfg9809sdfgsdgf\\")\\n                      (filter \#(Character/isDigit %))\\n                      (map int)\\n                      (sort))" "(->> (into [] \\"sdfg9809sdfgsdgf\\")\\n                      (filter \#(Character/isDigit %))\\n                      (map str)\\n                      (sort))" "(->> (into [] \\"sdfg9809sdfgsdgf\\")\\n                      (filter \#(Character/isDigit %))\\n                      (map str)\\n                      (map int)\\n                      (sort))" "(->> (into [] \\"sdfg9809sdfgsdgf\\")\\n                      (filter \#(Character/isDigit %))\\n                      (sort)\\n                      (map str))" "(->> (into [] \\"sdfg9809sdfgsdgf\\")\\n                      (filter \#(Character/isDigit %))\\n                      (sort)\\n                      (map str)\\n                      (map int))" "(->> (into [] \\"125439863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      (sort)\\n                      (map str)\\n                      (map int))" "(->> (into [] \\"125439863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      (sort)\\n                      (map str)\\n                      )" "(->> (into [] \\"125439863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      \\n                      (map str)\\n                      (map int)\\n                      )" "(->> (into [] \\"125439863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      \\n                      (map str)\\n                      (map \#(int %))\\n                      )" "(int \\"5\\")" "(->> (into [] \\"125439863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      \\n                      (map str)\\n                      (map parse-int)\\n                      )" "(->> (into [] \\"125439863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      \\n                      (map str)\\n                      (map parse-number)\\n                      )" "(->> (into [] \\"125439863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      \\n                      (map str)\\n                      (map read-string)\\n                      )" "(->> (into [] \\"12540039863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      \\n                      (map str)\\n                      (map read-string)\\n                      )" "(->> (into [] \\"12540039863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      (map str)\\n                      (map read-string)\\n                      (sort)\\n                      )" "(->> (into [] \\"12540039863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      (map str)\\n                      (map read-string)\\n                      (sort)\\n                      (reverse))" "(->> (into [] \\"12540039863fdgoisdfg7643\\")\\n                      (filter \#(Character/isDigit %))\\n                      (map read-string)\\n                      (sort)\\n                      (reverse))" "(ns Solution\\n  (\:gen-class))\\n\\n; Auto-generated code below aims at helping you parse\\n; the standard input according to the problem statement.\\n\\n(defn member?\\n  [item series]\\n  (if (some \#(\= item %) series) \\n    true \\n    false))\\n\\n\\n  \\n    (let [chars (into [] input)\\n    input* (->> chars\\n                   (filter \#(Character/isDigit %))\\n                   (map str)\\n                   (map read-string)\\n                   (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         input*\\n                         (reverse input*))]\\n          (println with-neg)))" "(defn input \\"2345kjhsdfg98797543\\")" "(def input \\"2345kjhsdfg98797543\\")" "(ns Solution\\n  (\:gen-class))\\n\\n; Auto-generated code below aims at helping you parse\\n; the standard input according to the problem statement.\\n\\n(defn member?\\n  [item series]\\n  (if (some \#(\= item %) series) \\n    true \\n    false))\\n\\n\\n  \\n    (let [chars (into [] input)\\n    input* (->> chars\\n                   (filter \#(Character/isDigit %))\\n                   (map str)\\n                   (map read-string)\\n                   (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         input*\\n                         (reverse input*))]\\n          (println with-neg)))" "(def input \\"2345kjhsdfg987975-43\\")" "(ns Solution\\n  (\:gen-class))\\n\\n; Auto-generated code below aims at helping you parse\\n; the standard input according to the problem statement.\\n\\n(defn member?\\n  [item series]\\n  (if (some \#(\= item %) series) \\n    true \\n    false))\\n\\n\\n  \\n    (let [chars (into [] input)\\n    input* (->> chars\\n                   (filter \#(Character/isDigit %))\\n                   (map str)\\n                   (map read-string)\\n                   (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         input*\\n                         (reverse input*))]\\n          (println with-neg)))" "(defn -main [& args]\\n  (let [N (read) _ (read-line) input (read-line)]\\n    \\n    (binding [*out* *err*]\\n      (println \\"Debug messages...\\"))\\n  \\n    (let [chars (into [] input)\\n          input* (->> chars\\n                         (filter \#(Character/isDigit %))\\n                         (map str)\\n                         (map read-string)\\n                         (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         input*\\n                         (cons \\"-\\" (reverse input*))]\\n          (println with-neg))\\n    ; Write answer to stdout\\n    (println \\"greatest\\")\\n    ))))" "(defn -main [& args]\\n  (let [N (read) _ (read-line) input (read-line)]\\n    \\n    (binding [*out* *err*]\\n      (println \\"Debug messages...\\"))\\n  \\n    (let [chars (into [] input)\\n          input* (->> chars\\n                         (filter \#(Character/isDigit %))\\n                         (map str)\\n                         (map read-string)\\n                         (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         input*\\n                         (cons \\"-\\" (reverse input*)))]\\n          (println with-neg)\\n          ; Write answer to stdout\\n          (println \\"greatest\\")\\n    ))))" "(defn poo [& args]\\n  (let [N (read) _ (read-line) input (read-line)]\\n    \\n    (binding [*out* *err*]\\n      (println \\"Debug messages...\\"))\\n  \\n    (let [chars (into [] input)\\n          input* (->> chars\\n                         (filter \#(Character/isDigit %))\\n                         (map str)\\n                         (map read-string)\\n                         (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         input*\\n                         (cons \\"-\\" (reverse input*)))]\\n          (println with-neg)\\n          ; Write answer to stdout\\n          (println \\"greatest\\")\\n    ))))" "(poo)" "(defn poo [& args]\\n  (let [N (read) _ (read-line) input (read-line)]\\n    \\n    (binding [*out* *err*]\\n      (println \\"Debug messages...\\"))\\n  \\n    (let [chars (into [] input)\\n          input* (->> chars\\n                         (filter \#(Character/isDigit %))\\n                         (map str)\\n                         (map read-string)\\n                         (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         input*\\n                         (cons \\"-\\" (reverse input*)))]\\n          (println with-neg)\\n          ; Write answer to stdout\\n          (println \\"greatest\\")\\n    ))))" "(poo)" "(defn -main [& args]\\n  (let [N (read) _ (read-line) input (read-line)]\\n    \\n    (binding [*out* *err*]\\n      (println \\"Debug messages...\\"))\\n  \\n    (let [chars (into [] input)\\n          input* (->> chars\\n                         (filter \#(Character/isDigit %))\\n                         (map str)\\n                         (map read-string)\\n                         (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         (reverse input*)\\n                         (cons \\"-\\" input*))]\\n          (println with-neg)\\n          ; Write answer to stdout\\n          (println \\"greatest\\")\\n    ))))" "(poo)" "(defn -main [& args]\\n  (let [N (read) _ (read-line) input (read-line)]\\n    \\n    (binding [*out* *err*]\\n      (println \\"Debug messages...\\"))\\n  \\n    (let [chars (into [] input)\\n          input* (->> chars\\n                         (filter \#(Character/isDigit %))\\n                         (map str)\\n                         (map read-string)\\n                         (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         (cons \\"-\\" (reverse input*))\\n                         input*)]\\n          (println with-neg)\\n          ; Write answer to stdout\\n          (println \\"greatest\\")\\n    ))))" "(poo)" "(defn poo [& args]\\n  (let [N (read) _ (read-line) input (read-line)]\\n    \\n    (binding [*out* *err*]\\n      (println \\"Debug messages...\\"))\\n  \\n    (let [chars (into [] input)\\n          input* (->> chars\\n                         (filter \#(Character/isDigit %))\\n                         (map str)\\n                         (map read-string)\\n                         (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         (cons \\"-\\" (reverse input*))\\n                         input*)]\\n          (println with-neg)\\n          ; Write answer to stdout\\n          (println \\"greatest\\")\\n    ))))" "(poo)" "(defn poo [& args]\\n  (let [N (read) _ (read-line) input (read-line)]\\n    \\n    (binding [*out* *err*]\\n      (println \\"Debug messages...\\"))\\n  \\n    (let [chars (into [] input)\\n          input* (->> chars\\n                         (filter \#(Character/isDigit %))\\n                         (map str)\\n                         (map read-string)\\n                         (sort))]\\n        (let [with-neg (if (member? \\\\- chars)\\n                         (cons \\"-\\" input)\\n                         (reverse input*))]\\n          (println with-neg)\\n          ; Write answer to stdout\\n          (println \\"greatest\\")\\n    ))))" "(poo)" "(make-quil-constant-map)" "(quil.util/make-quil-constant-map)" "(use 'quil.util)" "(generate-quil-constants)" "(print-matrix)" "(quil.core/print-matrix)" "(reset-matrix)" "(double 5)" "(float 5)" "(identical? (float 5) (double 5))" "(reset-matrix)" "(\= (float 5) (double 5))" "(\=\= (float 5) (double 5))" "(lerp 1 0.4 0.5)" "(x-range)" "(map float (range (first x-range)\\n                                     (last x-range)\\n                                     (/ (range-width x-range) num-sections)))" "(conj '(1 2 3) 4)" "(con '(1 2 3) 4)" "(cons '(1 2 3) 4)" "(cons 4 '(1 2 3))" "(conj 4 '(1 2 3))" "(append)" "append" "@append" "\#append" "(append '(1 2 3) 4)" "(defn append\\n  [lst item]\\n  (list (conj (vec lst) item)))" "(append '(1 2 3) 4)" "(defn append\\n  [lst item]\\n  (list (cons (vec lst) item)))" "(append '(1 2 3) 4)" "(defn append\\n  [lst item]\\n  (list (conj *(vec lst) item)))" "(append '(1 2 3) 4)" "(conj 1 2 3 '(4 4 4))" "(cons '(4 4 4) 3 3 3)" "(defn append\\n  [lst item]\\n  (reverse (conj (reverse lst) item)))" "(append '(1 2 3) 4)" "(defn maplist [func coll]\\n  (map (fn [row] (map func row)) coll))" "(maplist \#(+ 2 %) [[1 2 3] [2 3 4] [1 1 1]])" "(*ns*)" "*ns*" "(type *ns*)" "(map *ns*)" "(keys *ns*)" "(ns-map)" "(ns-map *ns*)" "(\#(identity `[~@%&]) 1 2 3 4)" "(\#(identity `[~@%]) 1 2 3 4)" "(def x {\:a 5 \:b 7})" "(x \:a)" "(\:a x)" "(def y [1 2 3])" "(y 0)" "(y 3)" "(y 2)" "(nth y 2)" "(map \#([%1 %2]) [1 2 3 4] [7 8 9 8])" "(map vec [1 2 3 4] [7 8 9 8])" "(map \#(vec %1 %2) [1 2 3 4] [7 8 9 8])" "(defn linspace [min max delta]\\n  (append (map float (range min max delta)) max))" "(linspace 0 10 0.5)" "(def x-range [-2 2])" "(apply linspace x-range 0.2)" "(apply linspace (concat x-range 0.2))" "(concat x-range 0.2)" "(concat x-range [0.2])" "(apply linspace (concat x-range [0.2]))" "(def x-range (linspace -5 5 0.2))\\n(def y-range (linspace 0 5 0.2))" "(defn domain-x-y []\\n  (let [domain-list (for [x x-range\\n                          y y-range])]\\n    [x y]))" "(domain-x-y)" "(defn domain-x-y []\\n  (let [domain-list (for [x x-range y y-range] [x y])]))" "(domain-x-y)" "(defn domain-x-y []\\n  (let [domain-list (for [x x-range y y-range] [x y])]\\n    domain-list))" "(domain-x-y)" "(defn domain-x-y []\\n  (let [domain-list (for [y y-range x x-range] [x y])]\\n    domain-list))" "(domain-x-y)" "(group-by 1 (domain-x-y))" "(for [x (range 1 (inc degree))\\n                       y (range 1 (inc 3))\\n                       \:when (and \\n                               (<\= (+ x y) 3)\\n                               (> (+ x y)) 0)]\\n                   {\:x x \:y y})" "[numeric.expresso.core \:refer \:all]" "(for [x (range 1 (inc degree))\\n                    y (range 1 (inc degree))\\n                    \:when (and \\n                            (<\= (+ x y) degree)\\n                            (> (+ x y)) 0)]\\n                {\:x x \:y y})" "(for [x (range 1 (inc degree))\\n                    y (range 1 (inc 3))\\n                    \:when (and \\n                            (<\= (+ x y) 3)\\n                            (> (+ x y)) 0)]\\n                {\:x x \:y y})" "(for [x (range 1 (inc 3))\\n                    y (range 1 (inc 3))\\n                    \:when (and \\n                            (<\= (+ x y) 3)\\n                            (> (+ x y)) 0)]\\n                {\:x x \:y y})" "(for [x (range 1 4)\\n                    y (range 1 4)\\n                    \:when (and \\n                            (<\= (+ x y) 4)\\n                            (> (+ x y)) 0)]\\n                {\:x x \:y y})" "(for [x (range 4)\\n                    y (range 4)\\n                    \:when (and \\n                            (<\= (+ x y) 4)\\n                            (> (+ x y)) 0)]\\n                {\:x x \:y y})" "(def degree 3)" "(for [x (range 1 (inc degree))\\n                    y (range 1 (inc degree))\\n                    \:when (and \\n                            (<\= (+ x y) degree)\\n                            (> (+ x y) 0))]\\n                {\:x x \:y y})" "(for [x (range 1 (inc degree))\\n                    y (range 1 (inc degree))\\n                    ]\\n                {\:x x \:y y})" "(for [x (range (inc degree))\\n                    y (range (inc degree))\\n                    ]\\n                {\:x x \:y y})" "(for [x (range (inc degree))\\n                    y (range (inc degree))\\n                    \:when (and \\n                            (<\= (+ x y) degree)\\n                            (> (+ x y) 0))" "(for [x (range (inc degree))\\n                    y (range (inc degree))\\n                    \:when (and \\n                            (<\= (+ x y) degree)\\n                            (> (+ x y) 0))]\\n                {\:x x \:y y})" "(def terms (for [x (range (inc degree))\\n                    y (range (inc degree))\\n                    \:when (and \\n                            (<\= (+ x y) degree)\\n                            (> (+ x y) 0))]\\n                {\:x x \:y y}))" "terms" "(zipmap terms (cycle [1 2 3 4]))" "(zip terms (cycle [1 2 3 4]))" "(zip vec terms (cycle [1 2 3 4]))" "(zip vector terms (cycle [1 2 3 4]))" "(map str [\\"a\\" \\"b\\" \\"c\\"] [\\"c\\" \\"d\\" \\"e\\"])" "(map \#(str % %2) [\\"a\\" \\"b\\" \\"c\\"] [\\"c\\" \\"d\\" \\"e\\"])" "(map \#(str %1 %2) [\\"a\\" \\"b\\" \\"c\\"] [\\"c\\" \\"d\\" \\"e\\"])" "(zip \#(str %1 %2) terms (cycle [1 2 3 4]))" "(map \#(str %1 %2) terms (cycle [1 2 3 4]))" "(map \#(assoc %1 \:coeff %2) terms (cycle [1 2 3 4]))" "(defn multivariate-polynomial [degree coefficients]\\n  (let [terms* (for [x (range (inc degree))\\n                     y (range (inc degree))\\n                     \:when (and \\n                             (<\= (+ x y) degree)\\n                             (> (+ x y) 0))]\\n                 {\:x x \:y y})\\n        terms  (map \#(assoc %1 \:coeff %2) \\n                    terms* (cycle coefficients))]\\n    {\:terms  terms\\n     \:func   (fn [x y]\\n               (apply + (map (fn [term]\\n                               (* (\:coeff term)\\n                                  (pow x (\:x term))\\n                                  (pow y (\:y term)))) terms)))\\n     \:string (reduce \\n               (fn [a b] (str a \\" + \\" b)) \\n               (map \\n                 (fn [term] \\n                   (str (\:coeff term) \\n                        \\"x^\\" (\:x term)\\n                        \\"y^\\" (\:y term))) \\n                 terms))}))" "(multivariate-polynomial 3 [1 4 2])" "(multivariate-polynomial 3 (take 10 (rand-int 20)))" "(multivariate-polynomial 3 (take 10 rand-int))" "(multivariate-polynomial 3 '(3 6 4 6 3 5 -10))" "(multivariate-polynomial 3 '(3 6 4 6 3 5 -10 2 3 5 3 6 4 6 5 7 6 8 5 6 43))" "(take 10 (repeatedly rand-int))" "(take 10 (repeatedly (rand-int 10)))" "(take 10 (repeat (rand-int 10)))" "(rand-int 10)" "(rand-int 100)" "(repeat (rand-int 10))" "(take 5 (repeat (rand-int 10)))" "(take n (repeatedly \#(rand-int n)))" "(def n 6)" "(take n (repeatedly \#(rand-int n)))" "(take n (repeatedly \#(rand-int -6 n)))" "(rand -10 10)" "(take 20 (repeatedly \#(- (rand-int 20) 10)))" "(rand 10)" "(defn multivariate-polynomial [degree coefficients]\\n  (let [terms* (for [x (range (inc degree))\\n                     y (range (inc degree))\\n                     \:when (and \\n                             (<\= (+ x y) degree)\\n                             (> (+ x y) 0))]\\n                 {\:x x \:y y})\\n        terms  (map \#(assoc %1 \:coeff %2) \\n                    terms* (cycle coefficients))]\\n    {\:terms  terms\\n     \:func   (fn [x y]\\n               (apply + (map (fn [term]\\n                               (* (\:coeff term)\\n                                  (pow x (\:x term))\\n                                  (pow y (\:y term)))) terms)))\\n     \:string (reduce \\n               (fn [a b] (str a \\" + \\" b)) \\n               (map \\n                 (fn [term] \\n                   (str (\:coeff term) \\n                        \\"x^\\" (\:x term)\\n                        \\"y^\\" (\:y term))) \\n                 terms))}))\\n\\n(defn random-polynomial [degree]\\n  (let [coefficients (take 20 (repeatedly \\n                                 \#(- (* (rand) 20) 10)))]\\n    (multivariate-polynomial degree coefficients)))" "(random-polynomial 5)" "(round 2.6346346 2)" "(with-precision 2\\n  (2.5346346))" "(use 'quil.core)" "(quil.core/round 2.364)" "(defn round* [x precision]\\n  (double (/ (round (* x precision)) precision)))" "(round* 2.346346 100)" "(count x-range)" "domain-x-y" "(count domain-x-y)" "(count x-range)" "(count y-range)" "(zipmap [1 2 3] [4 5 6])" "(identity-matrix 3)" "(identity-matrix 3 3)" "(clojure.core.matrix/identity-matrix 3 3)" "(clojure.core.matrix/identity-matrix 3)" "(conj [1 2] 0)" "(\:domain state)" "(transform-domain \\n                                      domain-x-y \\n                                      (mat/identity-matrix 3 3))" "(bean {\:a 4 \:b 4})" "(values {\:a 4 \:b 4})" "(vals {\:a 4 \:b 4})" "(keys {\:a 4 \:b 4})" "(use 'algo.graphs)" "(transform-domain \\n                                      domain-x-y \\n                                      (mat/identity-matrix 3 3))" "(def d (transform-domain \\n                                      domain-x-y \\n                                      (mat/identity-matrix 3 3)))" "d" "(map \#(str %) d)" "(map \#(type %) d)" "(map (fn [[k v]] (str k \\"--\\" v)) d)" "(partition-by (fn [[k v]] (second v)) d)" "(map (fn [[k v]] v) d)" "(map (fn [[k v]] (first v)) d)" "(map (fn [[k v]] (second v)) d)" "(def d (transform-domain \\n                                      domain-x-y \\n                                      (mat/identity-matrix 3 3)))" "d" "(map (fn [[k v]] (second v)) d)" "d" "(map (fn [[k v]] (second k)) d)" "(sort-by (fn [[k v]] (second k)) d)" "(def d (transform-domain \\n                                      domain-x-y \\n                                      (mat/identity-matrix 3 3)))" "d" "(sort-by (fn [[k v]] (second k)) d)" "(sort-by (fn [[k v]] [(second k) (first k)]) d)" "state" "(\:domain state)" "(get \:domain state)" "(get state \:domain)" "(let [domain           (transform-domain \\n                          domain-x-y \\n                          (mat/identity-matrix 3 3))\\n       surface-function (random-polynomial \\n                          polynomial-degree)]\\n   \\n   {\:domain             domain\\n    \:surface-function   surface-function\\n    \:vertices           (->> domain\\n                          (get-vertices surface-function)\\n                          sort-vertices)})" "(get state \:domain)" "\:reset" "\:clear" "(reduce concat [] [1 2 3 4 5])" "(domain-x-y)" "domain-x-y" "(def d (transform-domain \\n                            domain-x-y \\n                            (mat/identity-matrix 3 3)))" "(->> d (get-vertices (\:func surface-function))\\n                            sort-vertices)" "(->> d \\n  (get-vertices (\:func surface-function))\\n                            sort-vertices)" "(setup)" "(let [domain             (transform-domain \\n                            domain-x-y \\n                            (mat/identity-matrix 3 3))\\n       surface-function   (random-polynomial \\n                            polynomial-degree)]\\n                          \\n   {\:domain               domain\\n    \:surface-function     surface-function\\n    \:vertices             (->> domain                          \\n                            (get-vertices (\:func surface-function))\\n                            sort-vertices)})" "(setup)" "(->> d \\n  (get-vertices (\:func surface-function))\\n                            sort-vertices)" "ns-publics" "(ns-publics)" "*ns*" "(dor *ns*)" "(dir *ns*)" "(ns-map)" "(all-ns)" "(interpose \\"-\\" [1 2 3 4 5])" "(interpose \\"-\\" [\\\\a \\\\w \\\\e])" "(cosh 5)" "(Math/cosh 5)" "(combo/cartesian-product \\n                  x-range y-range [0])" "(count (combo/cartesian-product \\n                  x-range y-range))" "(count (for [y y-range x x-range] [x y]))" "(def A (combo/cartesian-product \\n                  x-range y-range))" "(def B (for [y y-range x x-range] [x y]))" "(\=\= A B)" "(\= A B)" "(\=? A B)" "(\=\=? A B)" "A" "B" "(for [y y-range x x-range] [x y])" "(sort-by (fn [[k v]] [(second k) (first k)]) \\n                         (combo/cartesian-product \\n                           x-range y-range))" "(sort (fn [[k v]] [(second k) (first k)]) \\n                         (combo/cartesian-product \\n                           x-range y-range))" "(sort-by (fn [[k v]] [(second k) (first k)]) \\n                            (for [y y-range x x-range] [x y]))" "(def A (for [y y-range x x-range] [x y]))" "A" "(sort-by (fn [[k v]] [(second k) (first k)]) \\n                            A)" "(sort-by (fn [[x y]] [y x]) \\n                            A)" "(sort-by (fn [[x y]] y x) \\n                            A)" "(sort-by (fn [[x y]] y y y x) \\n                            A)" "(sort-by (fn [[x y]] [y x]) \\n                         (combo/cartesian-product \\n                           x-range y-range))" "(-> domain-x-y\\n                            (transform-domain \\n                              (mat/identity-matrix 3 3))\\n                            (sort-vertices))" "(zipmap domain-x-y domain-x-y)" "(def domain-x-y (sort-by (fn [[x y]] [y x]) \\n                         (combo/cartesian-product \\n                           x-range y-range)))" "domain-x-y" "(zipmap domain-x-y domain-x-y)" "(map \#(mat/add & [1 1]) domain-map)" "(map \#(mat/add % [1 1]) domain-map)" "domain-map" "(map (fn [[k v]] [k (mat/add v [1 1])]) domain-map)" "(map (fn [[k v]] [k (mat/mul v 0.0001)]) domain-map)" "(-> domain-map\\n                            (transform-domain \\n                              (mat/identity-matrix 3 3))\\n                            (sort-vertices))" "domain-map" "(array-map \:a 4 \:b 5)" "(first (array-map \:a 4 \:b 5))" "(map \#([% %]) [1 2 3 4])" "(map \#(([% %])) [1 2 3 4])" "(map \#(vector % %) [1 2 3 4])" "(map \#(% %) [1 2 3 4])" "(reduce concat (map \#(vector % %) [1 2 3 4]))" "(def domain-map (array-map (reduce concat (map \#(vector % %) domain-x-y))))" "domain-x-y" "(reduce concat (map \#(vector % %) domain-x-y))" "(array-map '(1 1 2 2 3 3 4 4))" "(map \#(vector % %) domain-x-y)" "(array-map (map \#(vector % %) domain-x-y))" "(count (map \#(vector % %) domain-x-y))" "(reduce concat (map \#(vector % %) domain-x-y))" "(count (reduce concat (map \#(vector % %) domain-x-y)))" "(def domain-map (zipmap domain-x-y domain-x-y))" "domain-map" "(interpose [1 2 3] [1 2 3])" "(interleave [1 2 3] [1 2 3])" "(array-map (interleave domain-x-y domain-x-y))" "(interleave domain-x-y domain-x-y)" "(vector (interleave domain-x-y domain-x-y))" "(apply array-map (interleave domain-x-y domain-x-y))" "(def domain-map (apply array-map (interleave domain-x-y \\n       (map (fn [[x y]] [x y 0]) domain-x-y))))" "domain-map" "(map (fn [[k v]] [k (mat/mul v 0.0001)]) domain-map)" "domain-map" "(transform-domain domain-map\\n                              (rotation-matrix 0 0 (/ PI 3))\\n                              \\n                              )" "(map (fn [[k v]] [k (mat/mul v 0.01)]) domain-map)" "(map (fn [[k v]] k (mat/mul v 0.01)) domain-map)" "domain-map" "(type domain-map)" "(transient domain-map)" "(type (first domain-x-y))" "(first domain-x-y)" "(type (fn []))" "(type \#())" "(type transform-domain)" "(function? transform-domain)" "domain-mapped" "(map \#(fn [[k v]] [k]) domain-mapped)" "(map (fn [[k v]] [k]) domain-mapped)" "(map (fn [[k v]] {k v}) domain-mapped)" "(mapcat (fn [[k v]] {k v}) domain-mapped)" "(merge (map (fn [[k v]] {k v}) domain-mapped))" "(mapcat (fn [[k v]] [k v]) domain-mapped)" "(array-map (mapcat (fn [[k v]] [k v]) domain-mapped))" "(map-array (mapcat (fn [[k v]] [k v]) domain-mapped))" "(apply array-map (mapcat (fn [[k v]] [k v]) domain-mapped))" "(def matrix (rotation-matrix 0 0 (/ PI 3)))" "matrix" "domain-mapped" "(map identity (vals domain-mapped))" "\\n(map \#(mat/mmul % matrix) (vals domain-mapped))"]
eclipse.preferences.version=1
